%%% DOCUMENTCLASS 
%%%-------------------------------------------------------------------------------

\documentclass[
a4paper, % Stock and paper size.
11pt, % Type size.
% article,
% oneside, 
onecolumn, % Only one column of text on a page.
% openright, % Each chapter will start on a recto page.
% openleft, % Each chapter will start on a verso page.
openany, % A chapter may start on either a recto or verso page.
]{memoir}

%%% PACKAGES 
%%%------------------------------------------------------------------------------

\usepackage[utf8]{inputenc} % If utf8 encoding
% \usepackage[lantin1]{inputenc} % If not utf8 encoding, then this is probably the way to go
\usepackage[T1]{fontenc}    %
\usepackage[english]{babel} % English please
\usepackage[final]{microtype} % Less badboxes

% \usepackage{kpfonts} %Font

\usepackage{amsmath,amssymb,mathtools} % Math

% \usepackage{tikz} % Figures
\usepackage{graphicx} % Include figures

\usepackage{braket} % Brackets

\usepackage{listings} % Listings for code
\usepackage[dvipsnames,svgnames]{xcolor} % Color for listing text

\usepackage{tikz}

%%% PAGE LAYOUT 
%%%------------------------------------------------------------------------------

\setlrmarginsandblock{0.15\paperwidth}{*}{1} % Left and right margin
\setulmarginsandblock{0.2\paperwidth}{*}{1}  % Upper and lower margin
\checkandfixthelayout

%%% SECTIONAL DIVISIONS
%%%------------------------------------------------------------------------------

\maxsecnumdepth{subsection} % Subsections (and higher) are numbered
\setsecnumdepth{subsection}

\makeatletter %
\makechapterstyle{standard}{
  \setlength{\beforechapskip}{0\baselineskip}
  \setlength{\midchapskip}{1\baselineskip}
  \setlength{\afterchapskip}{8\baselineskip}
  \renewcommand{\chapterheadstart}{\vspace*{\beforechapskip}}
  \renewcommand{\chapnamefont}{\centering\normalfont\Large}
  \renewcommand{\printchaptername}{\chapnamefont \@chapapp}
  \renewcommand{\chapternamenum}{\space}
  \renewcommand{\chapnumfont}{\normalfont\Large}
  \renewcommand{\printchapternum}{\chapnumfont \thechapter}
  \renewcommand{\afterchapternum}{\par\nobreak\vskip \midchapskip}
  \renewcommand{\printchapternonum}{\vspace*{\midchapskip}\vspace*{5mm}}
  \renewcommand{\chaptitlefont}{\centering\bfseries\LARGE}
  \renewcommand{\printchaptertitle}[1]{\chaptitlefont ##1}
  \renewcommand{\afterchaptertitle}{\par\nobreak\vskip \afterchapskip}
}
\makeatother

\chapterstyle{standard}

\setsecheadstyle{\normalfont\large\bfseries}
\setsubsecheadstyle{\normalfont\normalsize\bfseries}
\setparaheadstyle{\normalfont\normalsize\bfseries}
\setparaindent{0pt}\setafterparaskip{0pt}

%%% FLOATS AND CAPTIONS
%%%------------------------------------------------------------------------------

\makeatletter                  % You do not need to write [htpb] all the time
\renewcommand\fps@figure{htbp} %
\renewcommand\fps@table{htbp}  %
\makeatother                   %

\captiondelim{\space } % A space between caption name and text
\captionnamefont{\small\bfseries} % Font of the caption name
\captiontitlefont{\small\normalfont} % Font of the caption text

\changecaptionwidth          % Change the width of the caption
\captionwidth{1\textwidth} %

%%% ABSTRACT
%%%------------------------------------------------------------------------------

\renewcommand{\abstractnamefont}{\normalfont\small\bfseries} % Font of abstract title
\setlength{\absleftindent}{0.1\textwidth} % Width of abstract
\setlength{\absrightindent}{\absleftindent}

%%% HEADER AND FOOTER 
%%%------------------------------------------------------------------------------

\makepagestyle{standard} % Make standard pagestyle

\makeatletter                 % Define standard pagestyle
\makeevenfoot{standard}{}{}{} %
\makeoddfoot{standard}{}{}{}  %
\makeevenhead{standard}{\bfseries\thepage\normalfont\qquad\small\leftmark}{}{}
\makeoddhead{standard}{}{}{\small\rightmark\qquad\bfseries\thepage}
% \makeheadrule{standard}{\textwidth}{\normalrulethickness}
\makeatother                  %

\makeatletter
\makepsmarks{standard}{
\createmark{chapter}{both}{shownumber}{\@chapapp\ }{ \quad }
\createmark{section}{right}{shownumber}{}{ \quad }
\createplainmark{toc}{both}{\contentsname}
\createplainmark{lof}{both}{\listfigurename}
\createplainmark{lot}{both}{\listtablename}
\createplainmark{bib}{both}{\bibname}
\createplainmark{index}{both}{\indexname}
\createplainmark{glossary}{both}{\glossaryname}
}
\makeatother                               %

\makepagestyle{chap} % Make new chapter pagestyle

\makeatletter
\makeevenfoot{chap}{}{\small\bfseries\thepage}{} % Define new chapter pagestyle
\makeoddfoot{chap}{}{\small\bfseries\thepage}{}  %
\makeevenhead{chap}{}{}{}   %
\makeoddhead{chap}{}{}{}    %
% \makeheadrule{chap}{\textwidth}{\normalrulethickness}
\makeatother

\nouppercaseheads
\pagestyle{standard}               % Choosing pagestyle and chapter pagestyle
\aliaspagestyle{chapter}{chap} %

%%% TIKZ
%%%------------------------------------------------------------------------------
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}


%%% NEW COMMANDS
%%%------------------------------------------------------------------------------

\newcommand{\p}{\partial} %Partial
% Or what ever you want

%%% TABLE OF CONTENTS
%%%------------------------------------------------------------------------------

\maxtocdepth{subsection} % Only parts, chapters and sections in the table of contents
\settocdepth{subsection}

\AtEndDocument{\addtocontents{toc}{\par}} % Add a \par to the end of the TOC

%%% INTERNAL HYPERLINKS
%%%-------------------------------------------------------------------------------

\usepackage{hyperref}   % Internal hyperlinks
\hypersetup{
pdfborder={0 0 0},      % No borders around internal hyperlinks
pdfauthor={I am the Author} % author
}
\usepackage{memhfixc}   %
\usepackage{textcomp}
%%% THE DOCUMENT
%%% Where all the important stuff is included!
%%%-------------------------------------------------------------------------------

\author{John Martin Jr.\\
        \texttt{jdm2213@columbia.edu}}
\title{\texttt{PDDLyte}\\ A Partial Implementation of The Planning Domain Definition Language}

\begin{document}

\frontmatter

\maketitle

% Listings -----------------------------------------------------------------------
\lstset{
  backgroundcolor=\color{Gainsboro},% choose the background color
  basicstyle=\ttfamily,             % the size of the fonts that are used for the code
  %breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %breaklines=true,                 % sets automatic line breaking
  %captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{blue},        % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; does not work with UTF-8
  frame=single,                     % adds a frame around the code
  %keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{orange},      % keyword style
  language=Lisp,                    % the language of the code
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                     % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  %numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},          % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                 % show spaces everywhere adding particular underscores; overrides 'showstringspaces'
  %showstringspaces=false,          % underline spaces within strings only
  %showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  %stringstyle=\color{mymauve},     % string literal style
  %tabsize=2,                       % sets default tabsize to 2 spaces
  %title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\begin{abstract}
The PDDLyte language, whose name derives from the Planning Domain Definition Language (PDDL)\cite{pddl98}, is a specification language used to formulate and solve planning problems. Similarly to PDDL, problems are specified with an initial state, a goal description, and a domain on which to plan over. From there, PPDLyte uses causal reasoning to deduce solutions, provided they exist, as a sequence of actions that map the initial state to the goal state(s). The PDDLyte language is limited in comparison to its predecessor, in that it will only support classical planning problems for a single agent: finite, fully-observable, deterministic, static environment descriptions. Another distinguishing characteristic of PDDLyte is in the way it's compiled.\\

Current PDDL implementations use LISP-based interpreters to verify the solutions. For most applications, this is where the life of PDDL ends. The PDDLyte implementation will go further and be compiled to C code, then to X86 assembly. With this design, the high-level reasoning of PDDLyte solutions will be amenable to systems-level C code interfaces.
\end{abstract}
%\clearpage

%\tableofcontents*
%\clearpage


\section{Background}

A planning problem asks if a goal description can be acheived from its initial state \cite{ai_rn}. If there's a tree of all possible actions from the initial state to every subsequent successor state, and the tree is indexed in such a way that allows us to read off the solution. This tree is of exponential size, which makes this approach impractical. A planning graph is a polynomial-size approximation to the full tree. This approach can't definitively answer if the goal is reachable from the initial state, btr it does estimate the number of steps it takes to reach thee foal. The esitmate is always correct when it reports the goal is not reachable; hence it never overestimates and is an admissible hueristic. Planning graphs work for propositional planning problems -- ones with no variables.Each action at level Ai is connected to its preconditions at Si and its effects at $S_{i+1}$. So a literal appears because an action caused it, wut we alo want to say that a literal can persist inf no action degates it. this is represented as a persistence actoin -- called a no-op.\\

What we build is a structure where ever action level constatins all the actions that are applicable in the ith state level along with the constraints saying that two actions cannont both be executed at the same level. every state level contains tll the literals that could result from any possible choice of actions in the previous action level along with the constraints saying which paits of literals are bot possible. it is important to not that the proces of constructing the planning graph does not require choosing among action, which woudl entail conbinatorial search. instaed, it just records the impossibility of certain choices using mutex links.\\

a planning fraph is polynomial in size of the planning problem. for a plannign problen with l literals and a actions, ach ith sstate has no more than l nodes and l squared mytex linkgs, and $2(al+l)$ precondition and effect links. thus an entire graph iwht n levels had size $O(n(a+l)^2)$. the time to build the fraph had the same complexity.\\

if any foal literal fails to appear in the final level of the graph, then tjhe problem is unsolvable. \\

i hope to encode the state transistion system which can be defined as a tuple $\Sigma = (S,A,E,\gamma)$. this formalism doesn't define an initial state and goal state.

planning is the explicit deliberation process that chooses and organizes actions by anticipating their outcomes -- how to achieve some prestate objectives computationally. understanding intellegnt behavior involves understanding plans that were made. and how those plans were formulated and executed. \\

two kinds of planning: domain specific, and domain independent.\\
- domain-specific -- perception planning, path planning, motion planning, manipulation planning, comminication planning\\
- domain-independent planning -- generic representations and techniques to plan for commonalities in plans. \\
- there's no consideration of time. it is implicit. plans are assumed to be sequential list of actions, i.e. no parallelism.\\

objects require typinf extension. iniitial state descirbes the topology.\\

a olan is a sequence of action $\pi = \lbrack a_1, ... ,a_k\rbrack$ with $k>0$. not every plan is a solution. therefore, a plan is a solution to a planning problem if the state transistion funciton $\gamma(s_0,\pi) = G$. Solutions are redundant if there exists a subsequence of \\

i'm using the srips represestation of classical planning representation.i use first order literals to define actions.


Underlying the PPDLyte language is a graph-based planner that generates solutions to the program's problem. The algorithm which computes the solution is the GraphPlan \cite{source} algorithm will be used to solve problems.\\

- Phase one --- plan graph expansion: creates graph encoding pair-wise consistency and reachability of actions and propositions from initial state. Graph includes, as a subset, all plans that are complete and consistent.\\
- Phase two --- Solution extraction: graph is treated as kind of a constraint satisfaction problem. Selects whether or not to perform each action at each time point by assigning CSP variables and testing consistency.\\

the solver works under the premise that an action can be executed in a given state, provided the preconditions are satisfied. That is $a \in A_{s} \leftrightarrow s \models P_{s}$

\section{Motivation}
Motivation for creating PDDLyte.


\section{PDDLyte Pipeline}

\begin{center}
\begin{tikzpicture}[->,>=stealth']

% pddlyte file node
\node[] (pdly_file)
{\texttt{.pdly} file};

% pddlyte compiler note
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pdly_file, 	        % Position is to the right of pdly_file
  node distance=3cm, 	            % distance to pdly_file
  anchor=center]                 % position relative to the center of the 'box'(pddlyte_comp) 
  (pddlyte_comp) 	
 {PDDLyte Compiler};
 
% gcc compiler
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pddlyte_comp, 	    % Position is to the right of pddlyte_comp
  node distance=5cm, 	            % distance to pddlyte_comp
  anchor=center]
  (gcc)
 {GCC};

% x86 assembler 
 \node[state,    	        % layout (defined above)
  text width=3cm, 	        % max text width
  below of= gcc, 	        % Position is to the right of gcc
  node distance=2cm, 	        % distance to gcc
  anchor=center]
 (assembler)
 {X86 Assembler};
 
% binary file
\node[
     text width=2cm, 	        % max text width
     left of= assembler, 	    % Position is to the right of assembler
     node distance=7.5cm, 	        % distance to assembler
     anchor=center](bin_file)
    {Binary file};

% audio file?
%\node[    	                % layout (defined above)
%  text width=1.5cm, 	        % max text width
%  left of= assembler, 	    % Position is to the right of assembler
%  node distance=8cm, 	        % distance to assembler
%  anchor=center](audio_file)
%{\texttt{.mp3} file};

 % draw the paths and and print some Text below/above the graph
 \path    (pdly_file)        edge                                               (pddlyte_comp)
          (pddlyte_comp)     edge node[anchor=south,above]{\texttt{.c} file}    (gcc)
          (gcc)              edge node[anchor=left,right]{\texttt{.o} file}    (assembler)
          (assembler)        edge                                              (bin_file);

          %(assembler)        edge                                              (audio_file);

\end{tikzpicture}
\end{center}


\section{Lexicon}
{\setlength{\parindent}{0cm}

The syntax in PDDLyte derives from PDDL. The components of each language focus around the classical-planning representation of STRIPS, which itself is a restricted, state-transition system $\Sigma = (S,A,\gamma)$ over a function-free, first-order language $\mathcal{L}$. For more information on the formalism of PDDL, see \cite{auto_planning}.\\
 
In essence, PDDLyte will interpret conjunctions of predicates, themselves comprised of grounded atoms and sets literals, in order to solve problems. Therefore, the language must represent atoms, literals, and booleans. Additionally, the PDDLyte language will support integer arithmetic for various quantifications. 

\subsection{Primitive types}

\textit{Boolean} --- True or false values.

\textit{Integers} --- Any element of the set $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \}$. 

\textit{Objects} --- Generic datatypes identified with symbols, consisting of one or more character elements from the ASCII set. Fluent objects must be prefixed with a question mark: \texttt{?<var>}.

\subsection{Structured types}

\textit{Lists} --- A set of components separated with spaces and enclosed with parentheses: the component's types can be dissimilar.

\textit{Atoms} --- An atom is a predicate with a specified number of object arguments. An atom is said to be grounded when they relate to specific objects with values -- not variables.

\subsection{Domains} 
Domains can be thought of as universe. What describes these universes are states, actions and means to use actions at states to make transitions. Only a single domain may be defined per file. 

\begin{lstlisting}
(define (domain <name>)
          (<types_def>)
        (<actions_def>)
    (<predicates_def>))
\end{lstlisting}

\textit{Types} --- Types are symbols that specify objects of the domain. This attribute is an extension of PDDL, but will be inherently supported with PDDLyte.

\textit{Actions} --- Actions are the operators that transition the system between states. These are represented as triples, $a = (name, precondition, effect)$, and are the basic elements of a solution \cite{strips70}. In PDDL, an action's name is considered both the unique symbol and a set of parameters that define the operation. The pre-conditions must be satisfied for the transition to take place. Furthermore, the effects must be valid according to an active problem description. If no pre-conditions are specified, then an action is always valid. 

\begin{lstlisting}
(:action  <name>
          :parameters     (<param_def>)
          :precondition (<precond_def>)
          :effect       (<effect_def>))
\end{lstlisting}

\textit{Parameters} are a list of atoms used in the action's precondition and effect conjunctions.

\begin{lstlisting}
:parameters (?<name> - <type> ... ?<name_n> - <type_n>)
\end{lstlisting}

\textit{Preconditions} are propositions that must be true for an operator to be applied. This is expressed as a logical conjunction of literals. \textit{Literals} are positive or negative atoms.

\begin{lstlisting}
:precondition (and (<literal>) ...)
\end{lstlisting}

\textit{Effects} describe changes that occur when an action is completed at the successor state. This is expressed as a logical conjunction of literals. Furthermore, developers should be mindful to balance the preconditions with the effects; as predicate states are not automatically negated by transitions.

\begin{lstlisting}
:effect (and (<literal>) ...)
\end{lstlisting}

\textit{Predicates} --- Predicates define relationships between object variables. These can be static relations that hold from state to state, or fluent relations. Each predicate is defined with a symbolic name and one or more object name-type groups; where the object name is separated from the type with a dash:

\begin{lstlisting}
(:predicates (pred ?<name> - <type> t...) ...)
\end{lstlisting}

\subsection{Problems}
Problems are triples defined as $P = (\Sigma, s_0, G)$. This inlcudes a domain $\Sigma$ an initial state $s_0$, and a set of ground literals describing the goal condition $G$.

\begin{lstlisting}
(define (problem <name>)
              (<domain>)
         (<objects_def>)
      (<init_state_def>)
   (<goal_descrip_def>))
\end{lstlisting}

\textit{Objects} --- Objects refer to those used in the problem configuration. Each object is declared with a symbolic name and one or more object name-type groups; where the object name is separated from the type with a dash:


\begin{lstlisting}
(:objects ?<name> - <type> ... ?<name_n> - <type_n>))
\end{lstlisting}

\textit{Initial State} --- The initial state defines the predicates that are true in the system's starting configuration. This can be any valid state within the domain and is written as a conjunction of ground literals.

\begin{lstlisting}
(:init <atom_list>)
\end{lstlisting}

\textit{Goal Description} --- The goal description defines the predicates that are true in the system's final configuration. This is a conjunction of grounded literals.

\begin{lstlisting}
(:goal <literal>)
\end{lstlisting}
}

\section{Operators}
Operators will be specified using prefix notation; where the operator is placed to the left of its arguments. This convention is adopted from PDDL, which inherits its syntax from LISP to simplify parsing.\\

{\setlength{\parindent}{0cm}
\textit{Comments} --- Comments begin with a semicolon (\texttt{;}) and terminate at the next new line. Furthermore, they do not nest and may not be composed within comments.

\begin{lstlisting}
; commentary ends when the line breaks
\end{lstlisting}

\subsection{Arithmetic operators}
A minimal level of integer arithmetic will be supported in PDDLyte. \\

\textit{Assignment} --- Explicit assignments are only permitted with integer values:

\begin{lstlisting}
(set <atom> <int>)
\end{lstlisting}

\textit{Modulus} --- The modulus of two integers can be computed:

\begin{lstlisting}
(mod <int> <int>)
\end{lstlisting}

\textit{Addition} --- Integer addition is supported for one or more numbers:

\begin{lstlisting}
(+ <int> ... <int_n>)
\end{lstlisting}

\textit{Subtraction} --- Integer subtraction is supported for one or more numbers:

\begin{lstlisting}
(- <int> ... <int_n>)
\end{lstlisting}

\subsection{Conditional Operators}

\textit{Equal} --- Comparing the value of one or more integers is accomplished with the \texttt{=} predicate. The result evaluates to true if every argument is equal to the others. Otherwise, the result is nil.

\begin{lstlisting}
(= <int> ... <int_n>)
\end{lstlisting}

\textit{Less than} --- The \texttt{<} predicate is used to compare if the arguments are in monotonically increasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(< <int> ... <int\_n>)
\end{lstlisting}

\textit{Greater than} --- The \texttt{>} predicate is used to compare if the arguments are in monotonically decreasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(> <int> ... <int\_n>)
\end{lstlisting}

\textit{Less than or equal to} --- The \texttt{<=} predicate is used to compare if the arguments are in monotonically non-decreasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(<= <int> ... <int\_n>)
\end{lstlisting}


\textit{Greater than or equal to} --- The \texttt{>=} predicate is used to compare if the arguments are in monotonically non-increasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(>= <int> ... <int\_n>)
\end{lstlisting}

\subsection{Boolean Operators}

\textit{Conjunction} --- Logical conjunctions are formed with the \texttt{and} predicate: 

\begin{lstlisting}
(and <literal>)
\end{lstlisting}

\textit{Disjunction} --- Logical disjunctions are formed with the \texttt{or} predicate:

\begin{lstlisting}
(or <literal>)
\end{lstlisting}

\textit{Negation} --- The value of a logical conjunction of literals is inverted with the \texttt{not} predicate. The function returns true if its argument is nil, otherwise false.

\begin{lstlisting}
(not <literal>)
\end{lstlisting}
}

\section{Keywords}
\begin{center}
\begin{tabular}{ l  l }
Keyword    & Description\\
\hline
\hline
\texttt{define}  & instantiates a domain or problem specification\\
\hline
\texttt{domain}  & domain specification \\
\hline
\texttt{problem} & problem specification \\
\hline
\texttt{:types}  & specifies a list of objects \\
\hline
\texttt{:action} & specifies an action \\
\hline
\texttt{:precondition} & specifies an action's preconditions \\
\hline
\texttt{:effect} & specifies an action's effects\\
\hline
\texttt{:parameters} & specifies an action's parameters\\
\hline
\texttt{:predicates} & specifies the domain predicates \\
\hline
\texttt{:objects} & specifies a problem's objects\\
\hline
\texttt{:init} & specifies a problem's initial state\\
\hline
\texttt{:goal} & specifies a problem's goal description\\
\hline
\end{tabular}
\end{center}

\section{Example program}
A program in PPDLyte consists of a domain and problem statement. Executing the program solves the problem and generates output.

\subsection{Pacman}
This program is simple to conceptualize, and therefore should be a good first step in generating plans. Pacman starts in one side of the world, with the goal of eating the bananas in another square. The solution is to simply move right twice.\\

\begin{center}
\begin{tikzpicture}[scale=2]
   \draw[black] (0,0) grid (3,1);
   \node[](pacman)at(0.5,0.5){\includegraphics[scale=0.1]{../imgs/pacman}};
   \node[](banana)at(2.5,0.5){\includegraphics[scale=0.4]{../imgs/banana}};
\end{tikzpicture}
\end{center}

Example PDDLyte code specifies the problem.

\lstinputlisting{../code/pacman.pdly}

\backmatter





%%% BIBLIOGRAPHY
%%% -------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{ref}

\end{document}