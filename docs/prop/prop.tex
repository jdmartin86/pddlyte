%%% DOCUMENTCLASS 
%%%-------------------------------------------------------------------------------

\documentclass[
a4paper, % Stock and paper size.
11pt, % Type size.
% article,
% oneside, 
onecolumn, % Only one column of text on a page.
% openright, % Each chapter will start on a recto page.
% openleft, % Each chapter will start on a verso page.
openany, % A chapter may start on either a recto or verso page.
]{memoir}

%%% PACKAGES 
%%%------------------------------------------------------------------------------

\usepackage[utf8]{inputenc} % If utf8 encoding
% \usepackage[lantin1]{inputenc} % If not utf8 encoding, then this is probably the way to go
\usepackage[T1]{fontenc}    %
\usepackage[english]{babel} % English please
\usepackage[final]{microtype} % Less badboxes

% \usepackage{kpfonts} %Font

\usepackage{amsmath,amssymb,mathtools} % Math

% \usepackage{tikz} % Figures
\usepackage{graphicx} % Include figures

\usepackage{braket} % Brackets

\usepackage{listings} % Listings for code
\usepackage[dvipsnames,svgnames]{xcolor} % Color for listing text

\usepackage{tikz}

%%% PAGE LAYOUT 
%%%------------------------------------------------------------------------------

\setlrmarginsandblock{0.15\paperwidth}{*}{1} % Left and right margin
\setulmarginsandblock{0.2\paperwidth}{*}{1}  % Upper and lower margin
\checkandfixthelayout

%%% SECTIONAL DIVISIONS
%%%------------------------------------------------------------------------------

\maxsecnumdepth{subsection} % Subsections (and higher) are numbered
\setsecnumdepth{subsection}

\makeatletter %
\makechapterstyle{standard}{
  \setlength{\beforechapskip}{0\baselineskip}
  \setlength{\midchapskip}{1\baselineskip}
  \setlength{\afterchapskip}{8\baselineskip}
  \renewcommand{\chapterheadstart}{\vspace*{\beforechapskip}}
  \renewcommand{\chapnamefont}{\centering\normalfont\Large}
  \renewcommand{\printchaptername}{\chapnamefont \@chapapp}
  \renewcommand{\chapternamenum}{\space}
  \renewcommand{\chapnumfont}{\normalfont\Large}
  \renewcommand{\printchapternum}{\chapnumfont \thechapter}
  \renewcommand{\afterchapternum}{\par\nobreak\vskip \midchapskip}
  \renewcommand{\printchapternonum}{\vspace*{\midchapskip}\vspace*{5mm}}
  \renewcommand{\chaptitlefont}{\centering\bfseries\LARGE}
  \renewcommand{\printchaptertitle}[1]{\chaptitlefont ##1}
  \renewcommand{\afterchaptertitle}{\par\nobreak\vskip \afterchapskip}
}
\makeatother

\chapterstyle{standard}

\setsecheadstyle{\normalfont\large\bfseries}
\setsubsecheadstyle{\normalfont\normalsize\bfseries}
\setparaheadstyle{\normalfont\normalsize\bfseries}
\setparaindent{0pt}\setafterparaskip{0pt}

%%% FLOATS AND CAPTIONS
%%%------------------------------------------------------------------------------

\makeatletter                  % You do not need to write [htpb] all the time
\renewcommand\fps@figure{htbp} %
\renewcommand\fps@table{htbp}  %
\makeatother                   %

\captiondelim{\space } % A space between caption name and text
\captionnamefont{\small\bfseries} % Font of the caption name
\captiontitlefont{\small\normalfont} % Font of the caption text

\changecaptionwidth          % Change the width of the caption
\captionwidth{1\textwidth} %

%%% ABSTRACT
%%%------------------------------------------------------------------------------

\renewcommand{\abstractnamefont}{\normalfont\small\bfseries} % Font of abstract title
\setlength{\absleftindent}{0.1\textwidth} % Width of abstract
\setlength{\absrightindent}{\absleftindent}

%%% HEADER AND FOOTER 
%%%------------------------------------------------------------------------------

\makepagestyle{standard} % Make standard pagestyle

\makeatletter                 % Define standard pagestyle
\makeevenfoot{standard}{}{}{} %
\makeoddfoot{standard}{}{}{}  %
\makeevenhead{standard}{\bfseries\thepage\normalfont\qquad\small\leftmark}{}{}
\makeoddhead{standard}{}{}{\small\rightmark\qquad\bfseries\thepage}
% \makeheadrule{standard}{\textwidth}{\normalrulethickness}
\makeatother                  %

\makeatletter
\makepsmarks{standard}{
\createmark{chapter}{both}{shownumber}{\@chapapp\ }{ \quad }
\createmark{section}{right}{shownumber}{}{ \quad }
\createplainmark{toc}{both}{\contentsname}
\createplainmark{lof}{both}{\listfigurename}
\createplainmark{lot}{both}{\listtablename}
\createplainmark{bib}{both}{\bibname}
\createplainmark{index}{both}{\indexname}
\createplainmark{glossary}{both}{\glossaryname}
}
\makeatother                               %

\makepagestyle{chap} % Make new chapter pagestyle

\makeatletter
\makeevenfoot{chap}{}{\small\bfseries\thepage}{} % Define new chapter pagestyle
\makeoddfoot{chap}{}{\small\bfseries\thepage}{}  %
\makeevenhead{chap}{}{}{}   %
\makeoddhead{chap}{}{}{}    %
% \makeheadrule{chap}{\textwidth}{\normalrulethickness}
\makeatother

\nouppercaseheads
\pagestyle{standard}               % Choosing pagestyle and chapter pagestyle
\aliaspagestyle{chapter}{chap} %

%%% TIKZ
%%%------------------------------------------------------------------------------
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}


%%% NEW COMMANDS
%%%------------------------------------------------------------------------------

\newcommand{\p}{\partial} %Partial
% Or what ever you want

%%% TABLE OF CONTENTS
%%%------------------------------------------------------------------------------

\maxtocdepth{subsection} % Only parts, chapters and sections in the table of contents
\settocdepth{subsection}

\AtEndDocument{\addtocontents{toc}{\par}} % Add a \par to the end of the TOC

%%% INTERNAL HYPERLINKS
%%%-------------------------------------------------------------------------------

\usepackage{hyperref}   % Internal hyperlinks
\hypersetup{
pdfborder={0 0 0},      % No borders around internal hyperlinks
pdfauthor={I am the Author} % author
}
\usepackage{memhfixc}   %
\usepackage{textcomp}
%%% THE DOCUMENT
%%% Where all the important stuff is included!
%%%-------------------------------------------------------------------------------

\author{John Martin Jr.\\
        \texttt{jdm2213@columbia.edu}}
\title{\texttt{PDDLyte}\\ A Partial Implementation of The Planning Domain Definition Language}

\begin{document}

\frontmatter

\maketitle

% Listings -----------------------------------------------------------------------
\lstset{
  backgroundcolor=\color{Gainsboro},% choose the background color
  basicstyle=\ttfamily,             % the size of the fonts that are used for the code
  %breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %breaklines=true,                 % sets automatic line breaking
  %captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{black},        % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; does not work with UTF-8
  frame=single,                     % adds a frame around the code
  %keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  %keywordstyle=\color{orange},      % keyword style
  language=Lisp,                    % the language of the code
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                     % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  %numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},          % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                 % show spaces everywhere adding particular underscores; overrides 'showstringspaces'
  %showstringspaces=false,          % underline spaces within strings only
  %showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  %stringstyle=\color{mymauve},     % string literal style
  %tabsize=2,                       % sets default tabsize to 2 spaces
  %title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\begin{abstract}
The PDDLyte language, whose name derives from the Planning Domain Definition Language (PDDL)\cite{pddl98}, is a symbolic, specification language used to formulate and solve planning problems. Similarly to PDDL, problems are specified with an initial state, a goal description, and a domain on which to plan over. From there, PPDLyte uses causal reasoning to deduce solutions, provided they exist, as a sequence of actions that map the initial state to the goal state(s). The PDDLyte language is limited in comparison to its predecessor, in that it will only support classical planning problems for a single agent: finite, fully-observable, deterministic, static environment descriptions. Another distinguishing characteristic of PDDLyte is in the way it's compiled.\\

Current PDDL implementations use CLISP-based interpreters to verify the solutions. For most applications, this is where the life of PDDL ends. The PDDLyte implementation will go further and be compiled to C code, then to X86 assembly. With this design, the high-level reasoning of PDDLyte solutions will be amenable to systems-level C code interfaces.
\end{abstract}
%\clearpage

%\tableofcontents*
%\clearpage


\section{Background: Planning}
{\setlength{\parindent}{0cm}

Automated planning is a branch of artificial intelligence that helps characterize intelligent behavior. Plans are explicitly deliberated in a process that chooses prearranged actions to achieve an objective. A planning problem asks if a goal description can be achieved from its initial state \cite{ai_rn}. In classical planning, actions are assumed to be finite sets of operators that transition a system from one state to another; hence a solution to this problem is a sequence, $\{A\}$, of actions. Every plausible state of a system can be represented as vertices on a  graph, and transitions that connect these states represent edges. In this framework, finding a solution is reduced to searching the state-space graph for a path that connects the initial state to the final state. Let's take a closer look at how this is done with the PDDLyte language.


\section{Example program: Pacman}

Pacman, with his ever-present, unperceptive objective to feed himself, can certainly benefit from automated planning. In this simple example, Pacman's goal, $G$, is to eat the bananas located in the third square; he originates in the first square, $s_0$. Pacman may move in any direction, provided it is between two adjacent squares, and he occupies the starting square.\\

\begin{center}
\begin{tikzpicture}[scale=2]
   \draw[black] (0,0) grid (3,1);
   \node[](pacman)at(0.5,0.5){\includegraphics[scale=0.1]{../imgs/pacman}};
   \node[](banana)at(2.5,0.5){\includegraphics[scale=0.4]{../imgs/banana}};
\end{tikzpicture}
\end{center}

With this small amount of information, the planning problem can be formulated with a triple: $P = (s_0, G, A)$. Where the set of accessible actions, $A$, are quickly realized as the only two available moves: move forward, or remain still. This makes planning graph simple to visualize.\\

\begin{center}
\begin{tikzpicture}[->,>=stealth']
\node [state, circle, node distance = 3cm] (1){$s_{0}$};
\node [state, circle, node distance = 3cm] (2) [right of=1]{$s_1$};
\node [state, circle, node distance = 3cm] (3) [right of=2]{$G$};

\path
    (1) edge (2)
    (2) edge (3)
    (1) edge [loop above] (1)
    (2) edge [loop above] (2)
    (2) edge [bend left] (1);

\end{tikzpicture}
\end{center}

When problems and their corresponding domains are specified formally in PDDLyte, graphs like these will be generated and transversed for solutions. If a solution is available -- which is guaranteed to be discerned from the completeness of the search algorithm -- then it will be returned as a sequence of actions, as shown in the example code.\\


\lstinputlisting{../code/pacman.pdly}


\section{Motivation}
Beyond Pacman, there exists a myriad of planning problems beckoning for description. What set of actions should a person take when driving to work? What operations are required to route secure network traffic around China? Using a planning-specification language organizes the high-level reason needed to solve these problems.\\

PDDLyte is designed as a symbolic language to accomodate the generality of problems it is intended to describe. The developer should have the means to create and give meaning to any entity.\\

Overall I hope the language can serve a purpose in the planning community. Perhaps those in academia will find comfort in a familiar syntax and run PDDLyte for instructional purposes. Those in the commercial realm may initially balk at the language's extensibility, but eventually discover uses for it in simulation or operations.

\section{PDDLyte Pipeline}
A planning domain and problem will be described in a \texttt{.pdly} file. The compiler will first translate into C code -- opening up the opportunity for interfacing with other code. From there, the code will be compiled into a machine language executable. 
\begin{center}
\begin{tikzpicture}[->,>=stealth']

% pddlyte file node
\node[] (pdly_file)
{\texttt{.pdly} file};

% pddlyte compiler note
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pdly_file, 	        % Position is to the right of pdly_file
  node distance=3cm, 	            % distance to pdly_file
  anchor=center]                 % position relative to the center of the 'box'(pddlyte_comp) 
  (pddlyte_comp) 	
 {PDDLyte Compiler};
 
% gcc compiler
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pddlyte_comp, 	    % Position is to the right of pddlyte_comp
  node distance=5cm, 	            % distance to pddlyte_comp
  anchor=center]
  (gcc)
 {GCC};

% x86 assembler 
 \node[state,    	        % layout (defined above)
  text width=3cm, 	        % max text width
  below of= gcc, 	        % Position is to the right of gcc
  node distance=2cm, 	        % distance to gcc
  anchor=center]
 (assembler)
 {Assembler};
 
% binary file
\node[
     text width=2.5cm, 	        % max text width
     left of= assembler, 	    % Position is to the right of assembler
     node distance=7.5cm, 	        % distance to assembler
     anchor=center](bin_file)
    {Machine Code};

% audio file?
%\node[    	                % layout (defined above)
%  text width=1.5cm, 	        % max text width
%  left of= assembler, 	    % Position is to the right of assembler
%  node distance=8cm, 	        % distance to assembler
%  anchor=center](audio_file)
%{\texttt{.mp3} file};

 % draw the paths and and print some Text below/above the graph
 \path    (pdly_file)        edge                                               (pddlyte_comp)
          (pddlyte_comp)     edge node[anchor=south,above]{\texttt{.c} file}    (gcc)
          (gcc)              edge node[anchor=left,right]{\texttt{.o} file}    (assembler)
          (assembler)        edge                                              (bin_file);

          %(assembler)        edge                                              (audio_file);

\end{tikzpicture}
\end{center}


\section{Lexicon}

The syntax in PDDLyte derives from PDDL. The components of each language focus around the classical-planning representation of STRIPS, which itself is a restricted, state-transition system $\Sigma = (S,A,\gamma)$ over a function-free, first-order language $\mathcal{L}$. For more information on the formalism of PDDL, see \cite{auto_planning}.\\
\subsection{Primitive types}

\textit{Symbols} --- Extensible data objects with property lists that denote objects.

\textit{Objects} --- Generic datatypes identified with symbols, consisting of one or more character elements from the ASCII set. Fluent objects must be prefixed with a question mark: \texttt{?<var>}.

\textit{Atoms} --- An atom is a predicate with a specified number of object arguments. An atom is said to be grounded when they relate to specific objects with values -- not variables.

\subsection{Structured types}

\textit{Lists} --- A set of components separated with spaces and enclosed with parentheses: the component's types can be dissimilar.

\subsection{Domains} 
Domains can be thought of as universe. What describes these universes are states, actions and means to use actions at states to make transitions. Only a single domain may be defined per file. 

\begin{lstlisting}
(define (domain <name>)
          (<types_def>)
        (<actions_def>)
    (<predicates_def>))
\end{lstlisting}

\textit{Types} --- Types are symbols that specify objects of the domain. This attribute is an extension of PDDL, but will be inherently supported with PDDLyte.

\textit{Actions} --- Actions are the operators that transition the system between states. These are represented as triples, $a = (name, precondition, effect)$, and are the basic elements of a solution \cite{strips70}. In PDDL, an action's name is considered both the unique symbol and a set of parameters that define the operation. The pre-conditions must be satisfied for the transition to take place. Furthermore, the effects must be valid according to an active problem description. If no pre-conditions are specified, then an action is always valid. 

\begin{lstlisting}
(:action  <name>
          :parameters     (<param_def>)
          :precondition (<precond_def>)
          :effect       (<effect_def>))
\end{lstlisting}

\textit{Parameters} are a list of atoms used in the action's precondition and effect conjunctions.

\begin{lstlisting}
:parameters (?<name> - <type> ... ?<name_n> - <type_n>)
\end{lstlisting}

\textit{Preconditions} are propositions that must be true for an operator to be applied. This is expressed as a logical conjunction of literals. \textit{Literals} are positive or negative atoms.

\begin{lstlisting}
:precondition (and (<literal>) ...)
\end{lstlisting}

\textit{Effects} describe changes that occur when an action is completed at the successor state. This is expressed as a logical conjunction of literals. Furthermore, developers should be mindful to balance the preconditions with the effects; as predicate states are not automatically negated by transitions.

\begin{lstlisting}
:effect (and (<literal>) ...)
\end{lstlisting}

\textit{Predicates} --- Predicates define relationships between object variables. These can be static relations that hold from state to state, or fluent relations. Each predicate is defined with a symbolic name and one or more object name-type groups; where the object name is separated from the type with a dash:

\begin{lstlisting}
(:predicates (pred ?<name> - <type> t...) ...)
\end{lstlisting}

\subsection{Problems}
Problems are triples defined as $P = (\Sigma, s_0, G)$. This inlcudes a domain $\Sigma$ an initial state $s_0$, and a set of ground literals describing the goal condition $G$.

\begin{lstlisting}
(define (problem <name>)
              (<domain>)
         (<objects_def>)
      (<init_state_def>)
   (<goal_descrip_def>))
\end{lstlisting}

\textit{Objects} --- Objects refer to those used in the problem configuration. This attribute is an extension of PDDL, but it's such a common requirement for classical plans that PDDLyte will inherently support it. Each object is declared with a symbolic name and one or more object name-type groups; where the object name is separated from the type with a dash:


\begin{lstlisting}
(:objects ?<name> - <type> ... ?<name_n> - <type_n>))
\end{lstlisting}

\textit{Initial State} --- The initial state defines the predicates that are true in the system's starting configuration. This can be any valid state within the domain and is written as a conjunction of ground literals.

\begin{lstlisting}
(:init (<literal>) ...)
\end{lstlisting}

\textit{Goal Description} --- The goal description defines the predicates that are true in the system's final configuration. This is a conjunction of grounded literals.

\begin{lstlisting}
(:goal (<literal>) ...)
\end{lstlisting}


\section{Operators}
Operators will be specified using prefix notation; where the operator is placed to the left of its arguments. This convention is adopted from PDDL, which inherits its syntax from LISP to simplify parsing.\\

\textit{Comments} --- Comments begin with a semicolon (\texttt{;}) and terminate at the next new line. Furthermore, they do not nest and may not be composed within comments.

\begin{lstlisting}
; commentary ends when the line breaks
\end{lstlisting}

\subsection{Atomic Literal Operators}

\textit{Conjunction} --- Logical conjunctions are formed with the \texttt{and} predicate: 

\begin{lstlisting}
(and <literal>)
\end{lstlisting}

\textit{Disjunction} --- Logical disjunctions are formed with the \texttt{or} predicate:

\begin{lstlisting}
(or <literal>)
\end{lstlisting}

\textit{Negation} --- The value of a logical conjunction of literals is inverted with the \texttt{not} predicate. The function returns true if its argument is nil, otherwise false.

\begin{lstlisting}
(not <literal>)
\end{lstlisting}


\section{Keywords}
\begin{center}
\begin{tabular}{ l  l }
Keyword    & Description\\
\hline
\hline
\texttt{define}  & instantiates a domain or problem specification\\
\hline
\texttt{domain}  & domain specification \\
\hline
\texttt{problem} & problem specification \\
\hline
\texttt{:types}  & specifies a list of objects \\
\hline
\texttt{:action} & specifies an action \\
\hline
\texttt{:precondition} & specifies an action's preconditions \\
\hline
\texttt{:effect} & specifies an action's effects\\
\hline
\texttt{:parameters} & specifies an action's parameters\\
\hline
\texttt{:predicates} & specifies the domain predicates \\
\hline
\texttt{:objects} & specifies a problem's objects\\
\hline
\texttt{:init} & specifies a problem's initial state\\
\hline
\texttt{:goal} & specifies a problem's goal description\\
\hline
\end{tabular}
\end{center}




Computationally, this accomplished Planning occurs with respect to a domain. There can be domain-specific plans focused on topics such as perception, motion, or communication, to name a few. There may also be domain-independent plans, which harness the commonality in domain-specific plans to plan for generalities.\\

In STRIPS-based planning, there is no explicit reference to time. Plans in this domain are assumed to have solutions which themselves are sequences of actions. This implies there is no parallelism in the solution.  Planning graphs are typically exponential in size. The backbone of this language uses a polynomial approximation to a full planning graph.


What we build is a structure where ever action level constatins all the actions that are applicable in the ith state level along with the constraints saying that two actions cannont both be executed at the same level. every state level contains all the literals that could result from any possible choice of actions in the previous action level along with the constraints saying which paits of literals are bot possible. it is important to note that the process of constructing the planning graph does not require choosing among action, which would entail combinatorial search. instead, it just records the impossibility of certain choices using mutex links.\\

If any goal literal fails to appear in the final level of the graph, then the problem is unsolvable. \\

- Phase one --- plan graph expansion: creates graph encoding pair-wise consistency and reachability of actions and propositions from initial state. Graph includes, as a subset, all plans that are complete and consistent.\\
- Phase two --- Solution extraction: graph is treated as kind of a constraint satisfaction problem. Selects whether or not to perform each action at each time point by assigning CSP variables and testing consistency.\\

the solver works under the premise that an action can be executed in a given state, provided the preconditions are satisfied. That is $a \in A_{s} \leftrightarrow s \models P_{s}$
}
\backmatter





%%% BIBLIOGRAPHY
%%% -------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{ref}

\end{document}