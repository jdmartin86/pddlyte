%%% DOCUMENTCLASS 
%%%-------------------------------------------------------------------------------

\documentclass[
a4paper, % Stock and paper size.
11pt, % Type size.
% article,
% oneside, 
onecolumn, % Only one column of text on a page.
% openright, % Each chapter will start on a recto page.
% openleft, % Each chapter will start on a verso page.
openany, % A chapter may start on either a recto or verso page.
]{memoir}

%%% PACKAGES 
%%%------------------------------------------------------------------------------

\usepackage[utf8]{inputenc} % If utf8 encoding
% \usepackage[lantin1]{inputenc} % If not utf8 encoding, then this is probably the way to go
\usepackage[T1]{fontenc}    %
\usepackage[english]{babel} % English please
\usepackage[final]{microtype} % Less badboxes

% \usepackage{kpfonts} %Font

\usepackage{amsmath,amssymb,mathtools} % Math

% \usepackage{tikz} % Figures
\usepackage{graphicx} % Include figures

\usepackage{braket} % Brackets

\usepackage{listings} % Listings for code
\usepackage[dvipsnames,svgnames]{xcolor} % Color for listing text

\usepackage{tikz}

%%% PAGE LAYOUT 
%%%------------------------------------------------------------------------------

\setlrmarginsandblock{0.15\paperwidth}{*}{1} % Left and right margin
\setulmarginsandblock{0.2\paperwidth}{*}{1}  % Upper and lower margin
\checkandfixthelayout

%%% SECTIONAL DIVISIONS
%%%------------------------------------------------------------------------------

\maxsecnumdepth{subsection} % Subsections (and higher) are numbered
\setsecnumdepth{subsection}

\makeatletter %
\makechapterstyle{standard}{
  \setlength{\beforechapskip}{0\baselineskip}
  \setlength{\midchapskip}{1\baselineskip}
  \setlength{\afterchapskip}{8\baselineskip}
  \renewcommand{\chapterheadstart}{\vspace*{\beforechapskip}}
  \renewcommand{\chapnamefont}{\centering\normalfont\Large}
  \renewcommand{\printchaptername}{\chapnamefont \@chapapp}
  \renewcommand{\chapternamenum}{\space}
  \renewcommand{\chapnumfont}{\normalfont\Large}
  \renewcommand{\printchapternum}{\chapnumfont \thechapter}
  \renewcommand{\afterchapternum}{\par\nobreak\vskip \midchapskip}
  \renewcommand{\printchapternonum}{\vspace*{\midchapskip}\vspace*{5mm}}
  \renewcommand{\chaptitlefont}{\centering\bfseries\LARGE}
  \renewcommand{\printchaptertitle}[1]{\chaptitlefont ##1}
  \renewcommand{\afterchaptertitle}{\par\nobreak\vskip \afterchapskip}
}
\makeatother

\chapterstyle{standard}

\setsecheadstyle{\normalfont\large\bfseries}
\setsubsecheadstyle{\normalfont\normalsize\bfseries}
\setparaheadstyle{\normalfont\normalsize\bfseries}
\setparaindent{0pt}\setafterparaskip{0pt}

%%% FLOATS AND CAPTIONS
%%%------------------------------------------------------------------------------

\makeatletter                  % You do not need to write [htpb] all the time
\renewcommand\fps@figure{htbp} %
\renewcommand\fps@table{htbp}  %
\makeatother                   %

\captiondelim{\space } % A space between caption name and text
\captionnamefont{\small\bfseries} % Font of the caption name
\captiontitlefont{\small\normalfont} % Font of the caption text

\changecaptionwidth          % Change the width of the caption
\captionwidth{1\textwidth} %

%%% ABSTRACT
%%%------------------------------------------------------------------------------

\renewcommand{\abstractnamefont}{\normalfont\small\bfseries} % Font of abstract title
\setlength{\absleftindent}{0.1\textwidth} % Width of abstract
\setlength{\absrightindent}{\absleftindent}

%%% HEADER AND FOOTER 
%%%------------------------------------------------------------------------------

\makepagestyle{standard} % Make standard pagestyle

\makeatletter                 % Define standard pagestyle
\makeevenfoot{standard}{}{}{} %
\makeoddfoot{standard}{}{}{}  %
\makeevenhead{standard}{\bfseries\thepage\normalfont\qquad\small\leftmark}{}{}
\makeoddhead{standard}{}{}{\small\rightmark\qquad\bfseries\thepage}
% \makeheadrule{standard}{\textwidth}{\normalrulethickness}
\makeatother                  %

\makeatletter
\makepsmarks{standard}{
\createmark{chapter}{both}{shownumber}{\@chapapp\ }{ \quad }
\createmark{section}{right}{shownumber}{}{ \quad }
\createplainmark{toc}{both}{\contentsname}
\createplainmark{lof}{both}{\listfigurename}
\createplainmark{lot}{both}{\listtablename}
\createplainmark{bib}{both}{\bibname}
\createplainmark{index}{both}{\indexname}
\createplainmark{glossary}{both}{\glossaryname}
}
\makeatother                               %

\makepagestyle{chap} % Make new chapter pagestyle

\makeatletter
\makeevenfoot{chap}{}{\small\bfseries\thepage}{} % Define new chapter pagestyle
\makeoddfoot{chap}{}{\small\bfseries\thepage}{}  %
\makeevenhead{chap}{}{}{}   %
\makeoddhead{chap}{}{}{}    %
% \makeheadrule{chap}{\textwidth}{\normalrulethickness}
\makeatother

\nouppercaseheads
\pagestyle{standard}               % Choosing pagestyle and chapter pagestyle
\aliaspagestyle{chapter}{chap} %

%%% TIKZ
%%%------------------------------------------------------------------------------
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}


%%% NEW COMMANDS
%%%------------------------------------------------------------------------------

\newcommand{\p}{\partial} %Partial
% Or what ever you want

%%% TABLE OF CONTENTS
%%%------------------------------------------------------------------------------

\maxtocdepth{subsection} % Only parts, chapters and sections in the table of contents
\settocdepth{subsection}

\AtEndDocument{\addtocontents{toc}{\par}} % Add a \par to the end of the TOC

%%% INTERNAL HYPERLINKS
%%%-------------------------------------------------------------------------------

\usepackage{hyperref}   % Internal hyperlinks
\hypersetup{
pdfborder={0 0 0},      % No borders around internal hyperlinks
pdfauthor={I am the Author} % author
}
\usepackage{memhfixc}   %
\usepackage{textcomp}
%%% THE DOCUMENT
%%% Where all the important stuff is included!
%%%-------------------------------------------------------------------------------

\author{John Martin Jr.\\
        \texttt{jdm2213@columbia.edu}}
\title{\texttt{PDDLyte}\\ A Partial Implementation of The Planning Domain Definition Language}

\begin{document}

\frontmatter

\maketitle

% Listings -----------------------------------------------------------------------
\lstset{
  backgroundcolor=\color{Gainsboro},% choose the background color
  basicstyle=\ttfamily,             % the size of the fonts that are used for the code
  %breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  %breaklines=true,                 % sets automatic line breaking
  %captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{blue},        % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; does not work with UTF-8
  frame=single,                     % adds a frame around the code
  %keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{orange},      % keyword style
  language=Lisp,                    % the language of the code
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                     % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  %numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},          % if not set, the frame-color may be changed on line-breaks within not-black text
  showspaces=false,                 % show spaces everywhere adding particular underscores; overrides 'showstringspaces'
  %showstringspaces=false,          % underline spaces within strings only
  %showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  %stringstyle=\color{mymauve},     % string literal style
  %tabsize=2,                       % sets default tabsize to 2 spaces
  %title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


%\begin{abstract}
%\lipsum[1-2]
%\end{abstract}
%\clearpage

%\tableofcontents*
%\clearpage

\section{Description}
{\setlength{\parindent}{0cm}

The PDDLyte language, whose name derives from the Planning Domain Definition Language (PDDL)\cite{pddl98}, is a specification language used to formulate and solve planning problems. Similarly to PDDL, problems are specified with an initial state, a set of actions, and a set of goal states. From there, PPDLyte uses causal reasoning to deduce solutions, provided they exist, as a sequence of actions that map the initial state to the goal state(s). The PDDLyte language is limited in comparison to its predecessor, in that it only supports classical planning problems for a single agent: finite, fully-observable, deterministic, static environment descriptions. Another distinguishing characteristic of PDDLyte is in the way it's compiled.\\

Current PDDL implementations use a LISP interpreter to verify the solutions. For most applications, this is where the life of PDDL ends. The PDDLyte implementation will go further and be compiled from C code to X86 assembly. With this design, the high-level reasoning of PDDLyte solutions are able to interface with systems-level C code.
}


\section{Background}
Background for languages similar to pddl.


\section{Motivation}
Motivation for creating PDDLyte.


\section{PDDLyte Pipeline}

\begin{center}
\begin{tikzpicture}[->,>=stealth']

% pddlyte file node
\node[] (pdly_file)
{\texttt{.pdly} file};

% pddlyte compiler note
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pdly_file, 	        % Position is to the right of pdly_file
  node distance=3cm, 	            % distance to pdly_file
  anchor=center]                 % position relative to the center of the 'box'(pddlyte_comp) 
  (pddlyte_comp) 	
 {PDDLyte Compiler};
 
% gcc compiler
 \node[state,    	            % layout (defined above)
  text width=3cm, 	            % max text width
  right of= pddlyte_comp, 	    % Position is to the right of pddlyte_comp
  node distance=5cm, 	            % distance to pddlyte_comp
  anchor=center]
  (gcc)
 {GCC};

% x86 assembler 
 \node[state,    	        % layout (defined above)
  text width=3cm, 	        % max text width
  below of= gcc, 	        % Position is to the right of gcc
  node distance=2cm, 	        % distance to gcc
  anchor=center]
 (assembler)
 {X86 Assembler};
 
% binary file
\node[
     text width=2cm, 	        % max text width
     left of= assembler, 	    % Position is to the right of assembler
     node distance=7.5cm, 	        % distance to assembler
     anchor=center](bin_file)
    {Binary file};

% audio file?
%\node[    	                % layout (defined above)
%  text width=1.5cm, 	        % max text width
%  left of= assembler, 	    % Position is to the right of assembler
%  node distance=8cm, 	        % distance to assembler
%  anchor=center](audio_file)
%{\texttt{.mp3} file};

 % draw the paths and and print some Text below/above the graph
 \path    (pdly_file)        edge                                               (pddlyte_comp)
          (pddlyte_comp)     edge node[anchor=south,above]{\texttt{.c} file}    (gcc)
          (gcc)              edge node[anchor=left,right]{\texttt{.o} file}    (assembler)
          (assembler)        edge                                              (bin_file);

          %(assembler)        edge                                              (audio_file);

\end{tikzpicture}
\end{center}


\section{Lexicon}
PDDLyte will compute boolean statements from conjunctions of atomic objects. In addition to these  datatypes, the PDDLyte language will support integer arithmetic for various quantifications.\\
PDDLyte is a strongly-typed language. It inherits nearly all its syntax from PDDL and only a subset of the datatypes. This is intended to provide the minimum set, required to solve classical-planning problems.

{\setlength{\parindent}{0cm}
\subsection{Primitive types}

\textit{Boolean} --- True or false values.

\textit{Strings} --- One or more character elements from the ASCII set comprise a string.

\textit{Integers} --- Any element of the set $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9 \}$. 

\subsection{Structured types}

\textit{Lists} --- A set of components separated with spaces and enclosed with parentheses: the component's types can be dissimilar.

\textit{Atoms} --- An atom has a string literal identifier and set of associated properties. Properties are a list of atoms. An atom has no properties when it's instantiated. Properties associate in the initial condition and as result of actions.

\subsection{Domains} 
Domains are the global problem descriptor. Only a single domain may be defined per file. A set of action schemas serve as a definition of a planning domain. The initial state and goal define the specific problem. \cite{ai_rn} All domain preconditions and action parameters must be prefixed with a question mark to distinguish them from the problem objects.

\begin{lstlisting}
(define (domain <name>)
          (<types_def>)
        (<actions_def>)
    (<predicates_def>))
\end{lstlisting}

\textit{Types} --- PDDLyte allows for any object to be defined as a list of atoms.

\textit{Actions} --- Actions are the operators that transition the system between states. These are the basic elements which a solution is built\cite{strips70}. There are pre-conditions and effects associated with each action. The pre-conditions must be satisfied for the transition to take place. Furthermore, the effects must be valid according to an active problem description. If no pre-conditions are specified, then an action is always valid. The action definition must know the type of parameter its preconditions are composed of. Actions are defined with a schema. 

\begin{lstlisting}
(:action  <name>
          :parameters     (<param_def>)
          :precondition (<precond_def>)
          :effect       (<effect_def>))
\end{lstlisting}

\textit{Parameters} are a list of atoms used in the action's precondition and effect conjunctions.

\begin{lstlisting}
(:parameters <atom_list>)
\end{lstlisting}

\textit{Preconditions} are propositions that must be true for an operator to be applied. This is expressed as a logical conjunction of literals.

\begin{lstlisting}
(:precondition <literal>)
\end{lstlisting}

\textit{Effects} describe changes that occur when an action is completed. Predicate states are not affected in anyway by Effects. When an action is complete, the effect is simply set. It is the responsibility of the user to negate the preconditions of an action upon completion. This conjunction of proposition will add an edge to the planning graph. Their negation will remove an edge from the planning graph. This is expressed as a conjunction of literals. Effects will always take place at time $t+1$

\begin{lstlisting}
(:effect <literal>)
\end{lstlisting}

\textit{Predicates} --- Predicates consist of a list of declarations that define a property of an object. These can be either true or false. 

\begin{lstlisting}
(:predicates <atom_list>)
\end{lstlisting}

\subsection{Problems}
Problems include an initial state and one or more goal descriptions. All problems are associated with a domain, which provide the context for the solution to be in.

\begin{lstlisting}
(define (problem <name>)
              (<domain>)
         (<objects_def>)
      (<init_state_def>)
   (<goal_descrip_def>))
\end{lstlisting}

\textit{Objects} --- specify a list of atoms used to define the problem space.

\begin{lstlisting}
(:objects <atom_list>)
\end{lstlisting}

\textit{Initial State} --- define the predicates that are true in the system's starting configuration. This can be any valid state within the domain. Unless predicates are specified as true in this statement, they are set false. This is a conjunction of ground atoms

\begin{lstlisting}
(:init <atom_list>)
\end{lstlisting}

\textit{Goal Description} --- The goal description defines the predicate(s) that are true in the system's final configuration(s). This is a conjunction of literals which may contain variables.

\begin{lstlisting}
(:goal <literal>)
\end{lstlisting}
}

\section{Operators}
Operators will be specified using prefix notation; where the operator is placed to the left of its arguments. This convention is adopted from PDDL, which inherits its syntax from LISP to simplify parsing.\\

{\setlength{\parindent}{0cm}
\textit{Comments} --- Comments begin with a semicolon (\texttt{;}) and terminate at the next new line. Furthermore, they do not nest and may not be composed within comments.

\begin{lstlisting}
; commentary ends when the line breaks
\end{lstlisting}

\subsection{Arithmetic operators}
A minimal level of integer arithmetic will be supported in PDDLyte. \\

\textit{Assignment} --- Explicit assignments are only permitted with integer values:

\begin{lstlisting}
(set <atom> <int>)
\end{lstlisting}

\textit{Modulus} --- The modulus of two integers can be computed:

\begin{lstlisting}
(mod <int> <int>)
\end{lstlisting}

\textit{Addition} --- Integer addition is supported for one or more numbers:

\begin{lstlisting}
(+ <int> ... <int_n>)
\end{lstlisting}

\textit{Subtraction} --- Integer subtraction is supported for one or more numbers:

\begin{lstlisting}
(- <int> ... <int_n>)
\end{lstlisting}

\subsection{Conditional Operators}

\textit{Equal} --- Comparing the value of one or more integers is accomplished with the \texttt{=} predicate. The result evaluates to true if every argument is equal to the others. Otherwise, the result is nil.

\begin{lstlisting}
(= <int> ... <int_n>)
\end{lstlisting}

\textit{Less than} --- The \texttt{<} predicate is used to compare if the arguments are in monotonically increasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(< <int> ... <int\_n>)
\end{lstlisting}

\textit{Greater than} --- The \texttt{>} predicate is used to compare if the arguments are in monotonically decreasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(> <int> ... <int\_n>)
\end{lstlisting}

\textit{Less than or equal to} --- The \texttt{<=} predicate is used to compare if the arguments are in monotonically non-decreasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(<= <int> ... <int\_n>)
\end{lstlisting}


\textit{Greater than or equal to} --- The \texttt{>=} predicate is used to compare if the arguments are in monotonically non-increasing order; if so, the result is true. Otherwise, the result is nil.

\begin{lstlisting}
(>= <int> ... <int\_n>)
\end{lstlisting}

\subsection{Boolean Operators}

\textit{Conjunction} --- Logical conjunctions are formed with the \texttt{and} predicate: 

\begin{lstlisting}
(and <literal>)
\end{lstlisting}

\textit{Disjunction} --- Logical disjunctions are formed with the \texttt{or} predicate:

\begin{lstlisting}
(or <literal>)
\end{lstlisting}

\textit{Negation} --- The value of a logical conjunction of literals is inverted with the \texttt{not} predicate. The function returns true if its argument is nil, otherwise false.

\begin{lstlisting}
(not <literal>)
\end{lstlisting}
}

\section{Keywords}
\begin{center}
\begin{tabular}{ l  l }
Keyword    & Description\\
\hline
\hline
\texttt{define}  & instantiates a domain or problem specification\\
\hline
\texttt{domain}  & domain specification \\
\hline
\texttt{problem} & problem specification \\
\hline
\texttt{:types}  & specifies a list of objects \\
\hline
\texttt{:action} & specifies an action \\
\hline
\texttt{:precondition} & specifies an action's preconditions \\
\hline
\texttt{:effect} & specifies an action's effects\\
\hline
\texttt{:parameters} & specifies an action's parameters\\
\hline
\texttt{:predicates} & specifies the domain predicates \\
\hline
\texttt{:objects} & specifies a problem's objects\\
\hline
\texttt{:init} & specifies a problem's initial state\\
\hline
\texttt{:goal} & specifies a problem's goal description\\
\hline
\end{tabular}
\end{center}


\section{GraphPlan Algorithm}
Underlying the PPDLyte language is a graph-based planner that generates solutions to the program's problem. The algorithm which computes the solution is the GraphPlan \cite{source} algorithm will be used to solve problems.\\

- Phase one --- plan graph expansion: creates graph encoding pair-wise consistency and reachability of actions and propositions from initial state. Graph includes, as a subset, all plans that are complete and consistent.\\
- Phase two --- Solution extraction: graph is treated as kind of a constraint satisfaction problem. Selects whether or not to perform each action at each time point by assigning CSP variables and testing consistency.\\

the solver works under the premise that an action can be executed in a given state, provided the preconditions are satisfied. That is $a \in A_{s} \leftrightarrow s \models P_{s}$

\section{Testing}
Testing procedures stressed two factors: function and performance. Testin compares an input-output pair to a specification. Unit testing validates every piece of the program independent from the rest of the code. Overall program. 

\section{Example program}
A program in PPDLyte consists of a domain and problem statement. Executing the program solves the problem and generates output.

\subsection{Monkeys and Bananas}
A monkey is in a room tormented by a bundle of bananas hanging from the ceiling, just out of its reach. Inside the room, there is also a chair and a stick. Both items are proportioned just right to allow the monkey enough reach to retrieve the bananas -- provided the monkey has the sense to use the items properly. Once the chair is positioned under the bananas, the monkey can step up and use the stick to wackk the bundle free. 
%\lstinputlisting{mnb.pdly}

\subsection{Pacman}
This program is simple to conceptualize, and therefore should be a good first step in generating plans. Pacman starts in one side of the world, with the goal of eating the bananas in another square. The solution is to simply move right twice.\\

\begin{center}
\begin{tikzpicture}[scale=2]
   \draw[black] (0,0) grid (3,1);
   \node[](pacman)at(0.5,0.5){\includegraphics[scale=0.1]{../imgs/pacman}};
   \node[](banana)at(2.5,0.5){\includegraphics[scale=0.4]{../imgs/banana}};
\end{tikzpicture}
\end{center}

Example PDDLyte code specifies the problem.



\backmatter





%%% BIBLIOGRAPHY
%%% -------------------------------------------------------------

\bibliographystyle{plain}
\bibliography{ref}

\end{document}